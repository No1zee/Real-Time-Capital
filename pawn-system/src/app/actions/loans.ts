"use server"

import { db } from "@/lib/db"
import { revalidatePath } from "next/cache"
import { redirect } from "next/navigation"
import { z } from "zod"
import { auth } from "@/auth"
import { logActivity } from "@/app/actions/admin/analytics"
import { LoanStatus, AssetType } from "@prisma/client"

const loanSchema = z.object({
    // Customer
    firstName: z.string().min(1, "First name is required"),
    lastName: z.string().min(1, "Last name is required"),
    nationalId: z.string().min(1, "National ID is required"),
    phoneNumber: z.string().min(1, "Phone number is required"),

    // Item
    itemName: z.string().min(1, "Item name is required"),
    category: z.string().min(1, "Category is required"),
    brand: z.string().optional(),
    model: z.string().optional(),
    itemDescription: z.string().min(1, "Description is required"),
    serialNumber: z.string().optional(),
    valuation: z.coerce.number().min(0, "Valuation must be positive"),
    images: z.string().optional(), // JSON string of image URLs
    valuationDetails: z.string().optional(), // JSON string for detailed attributes

    // Loan
    principalAmount: z.coerce.number().min(0, "Principal amount must be positive"),
    interestRate: z.coerce.number().min(0, "Interest rate must be positive"),
    durationDays: z.coerce.number().int().min(1, "Duration must be at least 1 day"),
    signatureUrl: z.string().optional(),
})

export type State = {
    errors?: {
        firstName?: string[]
        lastName?: string[]
        nationalId?: string[]
        phoneNumber?: string[]
        itemName?: string[]
        category?: string[]
        brand?: string[]
        model?: string[]
        itemDescription?: string[]
        serialNumber?: string[]
        valuation?: string[]
        images?: string[]
        valuationDetails?: string[]
        principalAmount?: string[]
        interestRate?: string[]
        durationDays?: string[]
        signatureUrl?: string[]
    }
    message?: string | null
}

export async function createLoan(prevState: State, formData: FormData) {
    const session = await auth()

    const validatedFields = loanSchema.safeParse({
        firstName: formData.get("firstName"),
        lastName: formData.get("lastName"),
        nationalId: formData.get("nationalId"),
        phoneNumber: formData.get("phoneNumber"),
        itemName: formData.get("itemName"),
        category: formData.get("category"),
        brand: formData.get("brand"),
        model: formData.get("model"),
        itemDescription: formData.get("itemDescription"),
        serialNumber: formData.get("serialNumber"),
        valuation: formData.get("valuation"),
        images: formData.get("images"),
        valuationDetails: formData.get("valuationDetails"),
        principalAmount: formData.get("principalAmount"),
        interestRate: formData.get("interestRate"),
        durationDays: formData.get("durationDays"),
        signatureUrl: formData.get("signatureUrl"),
    })

    if (!validatedFields.success) {
        console.error("LOAN VALIDATION FAILED:", validatedFields.error.flatten().fieldErrors)
        return {
            errors: validatedFields.error.flatten().fieldErrors,
            message: "Missing Fields. Failed to Create Loan.",
        }
    }

    const {
        firstName,
        lastName,
        nationalId,
        phoneNumber,
        itemName,
        category,
        brand,
        model,
        itemDescription,
        serialNumber,
        valuation,
        images,
        valuationDetails,
        principalAmount,
        interestRate,
        durationDays,
        signatureUrl,
    } = validatedFields.data

    try {
        // 1. Find or Create Customer
        let customer = await db.customer.findUnique({
            where: { nationalId },
        })

        if (!customer) {
            customer = await db.customer.create({
                data: {
                    // id: auto-generated by @default(cuid())
                    firstName,
                    lastName,
                    nationalId,
                    phoneNumber,
                    updatedAt: new Date(),
                },
            })
        }

        // 2. Calculate Due Date
        const startDate = new Date()
        const dueDate = new Date(startDate)
        dueDate.setDate(dueDate.getDate() + durationDays)

        // 3. Create Loan and Item
        const loan = await db.loan.create({
            data: {
                customerId: customer.id,
                principalAmount,
                interestRate,
                durationDays,
                startDate,
                dueDate,
                status: "PENDING",
                updatedAt: new Date(),
                signatureUrl,
                Item: {
                    create: {
                        // id: auto-generated
                        name: itemName,
                        category: category as AssetType,
                        brand,
                        model,
                        description: itemDescription,
                        serialNumber,
                        valuation,
                        status: "PENDING_VALUATION",
                        images: images || "[]",
                        valuationDetails,
                        updatedAt: new Date(),
                    },
                },
            },
        })

        // 4. Log Activity for Admin Visibility
        if (session?.user?.id) {
            await logActivity("APPLY_LOAN", {
                loanId: loan.id,
                amount: principalAmount,
                item: itemName
            })
        }

    } catch (error) {
        console.error("Database Error createLoan:", error)
        return {
            message: "Database Error: Failed to Submit Application.",
        }
    }

    revalidatePath("/loans")
    revalidatePath("/loans")
    // redirect("/loans") // Let client handle navigation for better UX
    return { success: true, message: "Application Submitted Successfully!" }
}



export async function updateLoanStatus(loanId: string, newStatus: LoanStatus) {
    try {
        // Update Loan
        await db.loan.update({
            where: { id: loanId },
            data: { status: newStatus },
        })

        // If Defaulted, mark item as FOR_SALE
        if (newStatus === "DEFAULTED") {
            const item = await db.item.findFirst({ where: { loanId } })
            if (item) {
                await db.item.update({
                    where: { id: item.id },
                    data: { status: "IN_AUCTION" },
                })
            }
        }

        // Log Status Change
        await logActivity("UPDATE_LOAN_STATUS", { loanId, newStatus })

        revalidatePath(`/loans/${loanId}`)
        revalidatePath("/loans")
        return { success: true }
    } catch (error) {
        return { success: false, message: "Failed to update status" }
    }
}



export async function acceptLoanOffer(loanId: string) {
    try {
        const session = await auth()
        if (!session?.user) return { success: false, message: "Unauthorized" }

        // 1. Fetch Loan & Item to get details
        const loan = await db.loan.findUnique({
            where: { id: loanId },
            include: { Item: true }
        })

        if (!loan || !loan.Item[0]) {
            return { success: false, message: "Loan or Item not found" }
        }

        const item = loan.Item[0]
        const principal = Number(item.finalValuation) || Number(item.valuation)

        if (principal <= 0) {
            return { success: false, message: "Invalid valuation amount" }
        }

        // 2. Determine Rates & Duration based on Asset Category
        let interestRate = 0 // Percentage
        let storageFeePercent = 0 // Percentage
        let durationDays = 30

        if (item.category === AssetType.VEHICLE) {
            // Motor vehicles: 4% for 30 days, Storage 21%
            interestRate = 4
            storageFeePercent = 21
            durationDays = 30
        } else {
            // Others: 2% for 14 days, Storage 18%
            interestRate = 2
            storageFeePercent = 18
            durationDays = 14
        }

        const storageFee = (principal * storageFeePercent) / 100

        // 3. Calculate Dates
        const startDate = new Date()
        const dueDate = new Date(startDate)
        dueDate.setDate(dueDate.getDate() + durationDays)

        // 4. Update Loan ( Activate )
        await db.loan.update({
            where: { id: loanId },
            data: {
                status: "ACTIVE",
                principalAmount: principal,
                interestRate: interestRate,
                storageFee: storageFee,
                durationDays: durationDays,
                startDate: startDate,
                dueDate: dueDate,
                termsAccepted: true
            },
        })

        // 5. Update Item Status
        await db.item.update({
            where: { id: item.id },
            data: {
                status: "PAWNED",
                valuationStatus: "OFFER_ACCEPTED"
            }
        })

        // 6. Log
        await logActivity("ACCEPT_LOAN_OFFER", {
            loanId,
            userId: session.user.id,
            details: `Principal: ${principal}, Interest: ${interestRate}%, Storage: ${storageFee}`
        })

        revalidatePath(`/portal/loans/${loanId}`)
        revalidatePath("/portal/loans")
        return { success: true, message: "Loan Activated Successfully!" }
    } catch (error) {
        console.error("Failed to accept offer:", error)
        return { success: false, message: "Failed to accept offer." }
    }
}
